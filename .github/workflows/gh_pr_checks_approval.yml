name: '[gh] pull request checks approval'

on:
  pull_request_target:
    branches:
      - master
      - main
      - v3.0-dev
      - v3.0
    types: [ opened, reopened ]
  workflow_run:
    workflows:
      - \[gh\] pull request review
    types: [ completed ]

jobs:
  pull_request_opened:
    if: contains(github.event.action, 'opened')
    outputs:
      pull_request_number: ${{ github.event.pull_request.number }}
      pull_request_head_sha: ${{ github.event.pull_request.head.sha }}
      run: 'true'
    runs-on: ubuntu-latest
    steps:
      - run: echo "Pull request opened"

  call_get_workflow_output:
    if: github.event.action == 'completed' && github.event.workflow_run.conclusion == 'success'
    uses: ./.github/workflows/reuse_get_workflow_output.yml
    with:
      workflow_run: ${{ github.event.workflow_run.id }}

  pull_request_approved:
    needs: call_get_workflow_output
    if: needs.call_get_workflow_output.outputs.action == 'submitted'
    outputs:
      pull_request_number: ${{ steps.parse_workflow_output.outputs.pull_request_number }}
      pull_request_head_sha: ${{ steps.parse_workflow_output.outputs.pull_request_head_sha }}
      run: ${{ steps.parse_workflow_output.outputs.run }}
    runs-on: ubuntu-latest
    steps:
    - name: Parse
      id: parse_workflow_output
      env:
        RAW: ${{ needs.call_get_workflow_output.outputs.raw }}
      shell: python
      run: |
        import json
        import os

        raw = os.getenv("RAW")
        data = json.loads(raw)
        with open(os.getenv("GITHUB_OUTPUT"), 'w', encoding='utf-8') as file:
          file.write('run=%s\n' % 'true' if data["review"]["state"] == 'approved' else 'false')
          file.write("pull_request_number=%s\n" % data["pull_request"]["number"])
          file.write("pull_request_head_sha=%s\n" % data["pull_request"]["head"]["sha"])

  call_approval_checks_run:
    needs: [ pull_request_opened, pull_request_approved ]
    if: always() && contains(needs.*.result, 'success') && !(contains(needs.*.result, 'failure')) && contains(needs.*.outputs.run, 'true')
    uses: ./.github/workflows/reuse_approve_checks_run.yml
    with:
      pull_request_number: ${{ fromJSON(needs.pull_request_opened.outputs.pull_request_number || needs.pull_request_approved.outputs.pull_request_number) }}
      pull_request_head_sha: ${{ needs.pull_request_opened.outputs.pull_request_head_sha || needs.pull_request_approved.outputs.pull_request_head_sha }}

  checks_approval_comment:
    needs: call_approval_checks_run
    if: needs.call_approval_checks_run.outputs.action_required == 'true'
    runs-on: ubuntu-latest
    env:
      safety_changes_message: |
        After a quick scan, I have approved workflow to run.
      risky_changes_message: |
        Sorry, due to risky changes, I can\'t approve workflow to run.
        Don\'t worry about it, our collaborators will handle it asap.
      tips_message: |
        :label: **I will not automatically test new commits in this PR**, until our collaborators to verified. To become verified, they should either approve this PR or apply the `action(approve-checks)` label to this PR.
    steps:
    - name: Token
      uses: navikt/github-app-token-generator@v1
      id: get-token
      with:
        private-key: ${{ secrets.PRIVATE_KEY }}
        app-id: ${{ secrets.APP_ID }}
    - name: Checks
      uses: actions/github-script@v6.1.0
      with:
        github-token: ${{ steps.get-token.outputs.token }}
        script: |
          const { issues } = github.rest;
          const os = require('os');

          let body = process.env['${{ needs.call_approval_checks_run.outputs.included_risk_files == 'true' && 'risky_changes_message' || 'safety_changes_message' }}'];
          ${{ contains(github.event.action, 'opened') && 'body += os.EOL + os.EOL + process.env.tips_message;' || '' }}

          await issues.createComment({
            issue_number: ${{ needs.call_approval_checks_run.outputs.pull_request_number }},
            body,
            ...context.repo
          });
